# Auto-updater spec

This document specifies the auto-update system for Cmdr using `tauri-plugin-updater`.

## Goals

1. **Automatic update checks**: Check for updates on app start and every 60 minutes
2. **Silent downloads**: Download updates in the background without interrupting the user
3. **Non-intrusive UI**: Show a subtle "Restart to update" prompt when ready
4. **Self-hosted endpoint**: Serve update manifest from `https://getcmdr.com/latest.json`
5. **Streamlined releases**: One-command release process with enforced changelog

## Architecture overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              Release flow                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Developer: ./scripts/release.sh 0.2.1                                  │
│           ↓                                                             │
│  Script validates:                                                      │
│    - CHANGELOG.md [Unreleased] section has content                      │
│    - Working tree is clean                                              │
│           ↓                                                             │
│  Script does:                                                           │
│    - Bump version in package.json, tauri.conf.json, Cargo.toml          │
│    - Transform [Unreleased] → [0.2.1] in CHANGELOG.md                   │
│    - git commit + git tag v0.2.1 + git push --tags                      │
│           ↓                                                             │
│  CI (release.yml, triggered by v* tag):                                 │
│    - Build universal macOS binary (aarch64 + x86_64)                    │
│    - Sign with TAURI_SIGNING_PRIVATE_KEY                                │
│    - Create GitHub Release with .dmg and .app.tar.gz                    │
│    - Generate latest.json with signature                                │
│    - Commit latest.json to /apps/website/public/                        │
│           ↓                                                             │
│  Website auto-deploys (~8 min after push)                               │
│           ↓                                                             │
│  Users receive update notification on next check                        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

```
┌────────────────────────────────────────────────────────────┐
│                     Update flow (client)                   │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  App starts                                                │
│           ↓                                                │
│  Check for updates (also every 60 min via setInterval)     │
│           ↓                                                │
│  Fetch https://getcmdr.com/latest.json                     │
│           ↓                                                │
│  Compare versions: latest.json.version > current?          │
│           ↓ yes                                            │
│  Download update silently in background                    │
│           ↓                                                │
│  Show toast: "New version available. Restart to update."   │
│           ↓                                                │
│  User clicks [Restart] → app relaunches with new version   │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

## Update manifest format

File: `/apps/website/public/latest.json`

```json
{
  "version": "0.2.1",
  "notes": "## What's new\n\n- Fixed rename bug on network drives\n- Improved keyboard navigation",
  "pub_date": "2025-01-13T12:00:00Z",
  "platforms": {
    "darwin-universal": {
      "signature": "dW50cnVzdGVkIGNvbW1lbnQ6IHNpZ25hdHVyZSBmcm9tIHRhdXJpIHNlY3JldCBrZXkKUlVRd...",
      "url": "https://github.com/vdavid/cmdr/releases/download/v0.2.1/Cmdr_universal.app.tar.gz"
    }
  }
}
```

Notes:
- `darwin-universal` covers both Apple Silicon and Intel Macs
- `signature` is the content of the `.sig` file generated by Tauri during build
- `notes` is extracted from CHANGELOG.md for that version
- `url` points to GitHub Releases (not the website)

## Tauri configuration

Add to `apps/desktop/src-tauri/tauri.conf.json`:

```json
{
  "plugins": {
    "updater": {
      "endpoints": ["https://getcmdr.com/latest.json"],
      "pubkey": "dW50cnVzdGVkIGNvbW1lbnQ6IG1pbmlzaWduIHB1YmxpYyBrZXk6...<YOUR_PUBLIC_KEY>"
    }
  }
}
```

Notes:
- The `pubkey` is the public key generated by `pnpm tauri signer generate`
- Only one endpoint needed since we self-host

## Dependencies

### Rust (Cargo.toml)

```toml
tauri-plugin-updater = "2"
tauri-plugin-process = "2"  # For relaunch()
```

### Frontend (package.json)

```json
{
  "dependencies": {
    "@tauri-apps/plugin-updater": "^2",
    "@tauri-apps/plugin-process": "^2"
  }
}
```

## Frontend implementation

### Update checker service

Create `apps/desktop/src/lib/services/updater.ts`:

```typescript
import { check, type Update } from '@tauri-apps/plugin-updater';
import { relaunch } from '@tauri-apps/plugin-process';

const CHECK_INTERVAL_MS = 60 * 60 * 1000; // 60 minutes

interface UpdateState {
  status: 'idle' | 'checking' | 'downloading' | 'ready';
  update: Update | null;
  error: string | null;
}

let updateState = $state<UpdateState>({
  status: 'idle',
  update: null,
  error: null
});

export function getUpdateState() {
  return updateState;
}

export async function checkForUpdates(): Promise<void> {
  if (updateState.status === 'downloading' || updateState.status === 'ready') {
    return; // Don't interrupt ongoing download or ready state
  }

  updateState.status = 'checking';
  updateState.error = null;

  try {
    const update = await check();

    if (update?.available) {
      updateState.status = 'downloading';
      await update.downloadAndInstall();
      updateState.status = 'ready';
      updateState.update = update;
    } else {
      updateState.status = 'idle';
    }
  } catch (error) {
    updateState.status = 'idle';
    updateState.error = error instanceof Error ? error.message : String(error);
    console.error('Update check failed:', error);
  }
}

export async function restartToUpdate(): Promise<void> {
  await relaunch();
}

export function startUpdateChecker(): () => void {
  // Check immediately on start
  checkForUpdates();

  // Check periodically
  const intervalId = setInterval(checkForUpdates, CHECK_INTERVAL_MS);

  // Return cleanup function
  return () => clearInterval(intervalId);
}
```

### Update notification component

Create `apps/desktop/src/lib/components/UpdateNotification.svelte`:

```svelte
<script lang="ts">
  import { getUpdateState, restartToUpdate } from '$lib/services/updater';

  const state = getUpdateState();

  function handleRestart() {
    restartToUpdate();
  }

  function handleDismiss() {
    // Just hide the notification for this session
    // It will reappear on next app launch
    dismissed = true;
  }

  let dismissed = $state(false);
</script>

{#if state.status === 'ready' && !dismissed}
  <div class="update-notification">
    <span class="update-text">
      New version available. Restart to update.
    </span>
    <div class="update-actions">
      <button class="update-button restart" onclick={handleRestart}>
        Restart
      </button>
      <button class="update-button later" onclick={handleDismiss}>
        Later
      </button>
    </div>
  </div>
{/if}

<style>
  .update-notification {
    position: fixed;
    top: var(--spacing-md);
    right: var(--spacing-md);
    background: var(--color-surface-elevated);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    padding: var(--spacing-sm) var(--spacing-md);
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    box-shadow: var(--shadow-lg);
    z-index: var(--z-notification);
  }

  .update-text {
    font-size: var(--font-size-sm);
    color: var(--color-text-primary);
  }

  .update-actions {
    display: flex;
    gap: var(--spacing-xs);
  }

  .update-button {
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-sm);
    font-size: var(--font-size-sm);
    cursor: pointer;
    border: none;
  }

  .update-button.restart {
    background: var(--color-accent);
    color: var(--color-text-on-accent);
  }

  .update-button.later {
    background: transparent;
    color: var(--color-text-secondary);
  }

  .update-button.later:hover {
    background: var(--color-surface-hover);
  }
</style>
```

### Integration in app layout

In `apps/desktop/src/routes/+layout.svelte`, add:

```svelte
<script>
  import { onMount } from 'svelte';
  import { startUpdateChecker } from '$lib/services/updater';
  import UpdateNotification from '$lib/components/UpdateNotification.svelte';

  onMount(() => {
    const cleanup = startUpdateChecker();
    return cleanup;
  });
</script>

<UpdateNotification />
<!-- rest of layout -->
```

## Rust plugin registration

In `apps/desktop/src-tauri/src/lib.rs`, register the plugins:

```rust
tauri::Builder::default()
    .plugin(tauri_plugin_updater::Builder::new().build())
    .plugin(tauri_plugin_process::init())
    // ... other plugins
```

## Release script

Create `scripts/release.sh`:

```bash
#!/bin/bash
set -euo pipefail

VERSION="$1"

if [[ -z "$VERSION" ]]; then
  echo "Usage: ./scripts/release.sh <version>"
  echo "Example: ./scripts/release.sh 0.2.1"
  exit 1
fi

# Validate version format
if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
  echo "Error: Version must be in format X.Y.Z (e.g., 0.2.1)"
  exit 1
fi

# Check for uncommitted changes
if ! git diff --quiet || ! git diff --staged --quiet; then
  echo "Error: Working tree has uncommitted changes. Commit or stash them first."
  exit 1
fi

# Check CHANGELOG.md has unreleased content
UNRELEASED_CONTENT=$(sed -n '/## \[Unreleased\]/,/## \[/p' CHANGELOG.md | sed '1d;$d' | grep -v '^$' || true)
if [[ -z "$UNRELEASED_CONTENT" ]]; then
  echo "Error: CHANGELOG.md has no entries under [Unreleased]."
  echo "Add release notes before releasing!"
  exit 1
fi

echo "Releasing version $VERSION..."

# Update version in package.json
cd apps/desktop
npm pkg set version="$VERSION"
cd ../..

# Update version in tauri.conf.json
cd apps/desktop/src-tauri
jq ".version = \"$VERSION\"" tauri.conf.json > tauri.conf.json.tmp
mv tauri.conf.json.tmp tauri.conf.json
cd ../../..

# Update version in Cargo.toml (using sed for simplicity)
sed -i '' "s/^version = \".*\"/version = \"$VERSION\"/" apps/desktop/src-tauri/Cargo.toml

# Update CHANGELOG.md: rename [Unreleased] to [version] and add new [Unreleased]
TODAY=$(date +%Y-%m-%d)
sed -i '' "s/## \[Unreleased\]/## [Unreleased]\n\n## [$VERSION] - $TODAY/" CHANGELOG.md

# Commit and tag
git add -A
git commit -m "chore(release): v$VERSION"
git tag "v$VERSION"

echo ""
echo "Release v$VERSION prepared locally."
echo "To publish, run: git push origin main --tags"
```

## CHANGELOG.md format

Create `CHANGELOG.md` at repo root:

```markdown
# Changelog

All notable changes to Cmdr will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.2.0] - 2025-01-10

- Initial public release
```

## CI workflow

Create `.github/workflows/release.yml`:

```yaml
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  release:
    name: Build and release
    runs-on: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install mise
        uses: jdx/mise-action@v2

      - name: Install tools with mise
        run: mise install

      - name: Install frontend dependencies
        run: pnpm install --frozen-lockfile
        working-directory: ./apps/desktop

      - name: Build and release
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          projectPath: ./apps/desktop
          tagName: ${{ github.ref_name }}
          releaseName: 'Cmdr ${{ github.ref_name }}'
          releaseBody: 'See CHANGELOG.md for details.'
          releaseDraft: false
          prerelease: false
          args: --target universal-apple-darwin

      - name: Extract changelog for this version
        id: changelog
        run: |
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"  # Remove 'v' prefix

          # Extract section for this version from CHANGELOG.md
          NOTES=$(sed -n "/## \[$VERSION\]/,/## \[/p" CHANGELOG.md | sed '1d;$d')

          # Escape for JSON
          NOTES="${NOTES//'%'/'%25'}"
          NOTES="${NOTES//$'\n'/'%0A'}"
          NOTES="${NOTES//$'\r'/'%0D'}"

          echo "notes=$NOTES" >> $GITHUB_OUTPUT

      - name: Get artifact paths and signatures
        id: artifacts
        run: |
          # Find the .app.tar.gz and its signature
          BUNDLE=$(find apps/desktop/src-tauri/target/universal-apple-darwin/release/bundle -name "*.app.tar.gz" | head -1)
          SIG_FILE="${BUNDLE}.sig"

          SIGNATURE=$(cat "$SIG_FILE")
          FILENAME=$(basename "$BUNDLE")

          echo "signature=$SIGNATURE" >> $GITHUB_OUTPUT
          echo "filename=$FILENAME" >> $GITHUB_OUTPUT

      - name: Generate latest.json
        run: |
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"

          cat > apps/website/public/latest.json << EOF
          {
            "version": "$VERSION",
            "notes": "${{ steps.changelog.outputs.notes }}",
            "pub_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "platforms": {
              "darwin-universal": {
                "signature": "${{ steps.artifacts.outputs.signature }}",
                "url": "https://github.com/vdavid/cmdr/releases/download/${{ github.ref_name }}/${{ steps.artifacts.outputs.filename }}"
              }
            }
          }
          EOF

      - name: Commit latest.json
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add apps/website/public/latest.json
          git commit -m "chore(release): update latest.json for ${{ github.ref_name }} [skip ci]"
          git push origin HEAD:main

```

## GitHub secrets required

| Secret                               | Description                                   |
|--------------------------------------|-----------------------------------------------|
| `TAURI_SIGNING_PRIVATE_KEY`          | Private key from `pnpm tauri signer generate` |
| `TAURI_SIGNING_PRIVATE_KEY_PASSWORD` | Password used when generating the key         |

Note: `GITHUB_TOKEN` is automatically provided by GitHub Actions.

## Security considerations

1. **Signature verification**: The updater plugin verifies signatures before applying updates
2. **HTTPS only**: Update manifest served over HTTPS
3. **No downgrade attacks**: Plugin refuses to "update" to older versions
4. **Public key pinned**: Public key is embedded in the app binary

## Future enhancements (not in MVP)

- [ ] Show "What's new" dialog after update completes
- [ ] Add Windows/Linux support when ready
- [ ] Add Apple code signing for Gatekeeper
- [ ] Add update progress indicator
- [ ] Allow users to disable auto-update checks in preferences

## References

- [Tauri Updater Plugin](https://github.com/tauri-apps/plugins-workspace/tree/v2/plugins/updater)
- [Tauri GitHub Actions Guide](https://v2.tauri.app/distribute/pipelines/github/)
- [tauri-apps/tauri-action](https://github.com/tauri-apps/tauri-action)
- [Keep a Changelog](https://keepachangelog.com/)
